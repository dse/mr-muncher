(*********************************************************************************************)

(*  GAME.P -- by Darren Embry -- Saturday, October 12, 1991
    This file contains the source code for the game portion of the program.  *)

procedure playthegame;

const
{ index values for arrays indexed by sprite #:  -1 = bonus; 0 = player; 1 or more = ghost }
  bonus = -1; player = 0;
{ increment values of x and y coordinates for each direction }
  incx : array [still..down] of integer = (0,-1,1,0,0);
  incy : array [still..down] of integer = (0,0,0,-1,1);
{ reverse direction for each direction }
  reversedir : array [still..down] of direction = (still,right,left,down,up);
{ right-hand turn direction for each direction }
  turnright : array [still..down] of direction = (still,up,down,right,left);
{ size of each animated sprite, in pixels }
  spritesizex = 8; spritesizey = 8;
{ size of a larger animated sprite, in pixels (banana or strawberry) }
  bonusspritesizex = 8; bonusspritesizey = 10;
{ difference between size of normal sprite and size of larger sprite, divided by 2 }
  spritesizeydif = 1;
{ screen coordinates for upper left-hand-corner of board }
  minx = 7; miny = 7;
{ maximum # of players in game; maximum # of ghosts on board }
  maxplayers = 2; maxghosts = 10;
{ # of men left on first man; "men left" when game over }
  startingmenleft = 2; gameover = -1;
{ center x-coordinate for displaying messages on right-hand side of screen }
  messagex = 267;
{ point value for each ghost }
  ghostscores = 4;
  ghostscore : array [1..4] of integer = (200,400,800,1600);
{ point value for each thing you can eat }
  dotscore = 10; energyscore = 50; cherryscore = 100;
  strawberryscore = 500; bananascore = 1000;
{ score at which you get extra man; # of points for each extra man after that }
  firstbonusman = 10000; eachbonusman = 30000;
{ screen text coordinates for scoring -- my standard graphics font slows it down too much }
  scorex : array [1..maxplayers] of integer = (30,30); { 1 to 40 }
  scorey : array [1..maxplayers] of integer = (5,18); { 1 to 25 }
{ we can safely display these using my standard font }
  roundx : array [1..maxplayers] of integer = (251,251); { standard graphics coordinates }
  roundy : array [1..maxplayers] of integer = (60,164);
  menx : array [1..maxplayers] of integer = (292,292);
  meny : array [1..maxplayers] of integer = (60,164);
{ constants for certain game variables.  See variables with similar names, declared under VAR
  section. }
  playerspeed_constant = 2; dangerousghostspeed_constant = 2;
  edibleghostspeed_constant = 1; bonusspeed_constant = 1;
  bonusappeartime_constant = 1000; timeyouhavetoeat_constant = 125;
  warningtime_constant = 30;

var
{ # of players playing the game; # of players left }
  numberofplayers,playersleft,
{ current player #; previous player # }
	currentplayer,previousplayer,
{ # of pixels for each sprite to move for each iteration of REPEAT UNTIL KILLED loop }
  playerincr, dangerousghostincr, edibleghostincr, bonusincr : word;
{ # of iterations until a bonus appears on the board, counts down to zero }
  bonusappeartime,
{ # of iterations, after eating energy pellets, you have time to eat ghosts on board.
  After time is up, ghosts change back to their dangerous colors.  Also counts down to zero. }
  timeyouhavetoeat,
{ when the countdown strikes this number, ghosts flash. }
  warningtime,
{ countdown until bonus appears on board }
  bonuscountdown,
{ coordinates for lower right corner of board }
  maxx,maxy,
{ amount of time (iterations) left to eat ghosts on board }
  timelefttoeat,
{ # that determines points you get for eating ghost }
  scorelevel : integer; { 1 to 4, for 200, 400, 800, and 1600 }
{ data for each player's current board (walls,pellets,etc.)  See constants declared in
  DATATYPE.P file for values }
  currentboarddata : array [1..maxplayers] of boardtype;
{ coordinates for each one-way gate on the player's board }
	onewaygatex,onewaygatey [1..maxplayers,1..maxghosts] of integer;
	onewaygates : array [1..maxplayers] of integer;
{ # of ghosts currently on board }
  numberofghosts : array [1..maxplayers] of byte;
{ initial coordinates for each sprite: -1 = bonus; 0 = player; 1..maxghosts = ghost }
  initspritex,initspritey : array [1..maxplayers,-1..maxghosts] of integer;
{ coordinates for each sprite }
  spritex,spritey : array [-1..maxghosts] of integer;
{ direction each sprite is going }
  spritedir : array [-1..maxghosts] of direction;
{ what kind of bonus is on board? }
  currentbonustype : (_cherry_,_strawberry_,_banana_,_extraman_);
{ values for current round, men left, and score for each player }
  currentround,menleft : array [1..maxplayers] of integer;
  currentscore : array [1..maxplayers] of real;
{ # of dots left on board for each player }
  dotsleft : array [1..maxplayers] of integer;
{ current status for each ghost (dangerous, edible) }
  ghoststatus : array [1..maxghosts] of (_dangerous_,_edible_);
{ saved image area used to put each sprite on board }
  whatwasthere : array [-1..maxghosts] of icon10;
{ determines whether each sprite can go in each direction }
  go : array [-1..maxghosts,still..down] of boolean;
{ future coordinates for each sprite }
  futurex,futurey : array [-1..maxghosts] of integer;
{ increment value of x and/or y coordinate for each sprite }
  increment : array [-1..maxghosts] of byte;
{ points to go until player gets extra man }
  extramancountdown : array [1..maxplayers] of integer;
{ determines fate of player by each ghost }
  fate : array [1..maxghosts] of (_nothing_,_eat_,_kill_);
{ is a bonus present on this board?; are sound effects on? }
  bonuspresent,
{ did player eat energy or food pellet; did player eat energy? }
  atesomething,ateenergy,
{ does program exit back to main menu (used in error)?; does ghost kill player? }
  exiting, killed : boolean;
{ character read from keyboard }
  ch : char;
{ has ghost passed his one-way gate yet? }
	passedonewaygate : array [1..maxghosts] of boolean;
{ coordinates of one-way gates for each ghost }
	ghostgatex,ghostgatey : array [1..maxghosts] of integer;

procedure screengraphwindow; { resets graphics window to entire screen }
begin setgraphwindow (0,0,319,199); end;

procedure gamegraphwindow; { sets graphics window to game board }
begin setgraphwindow (minx,miny,maxx,maxy); end;

procedure displaysoundstatus;
{ displays current sound status (ON or OFF) }
var x1,y1,x2,y2 : integer;
begin
  savegraphwindow (x1,y1,x2,y2);
  screengraphwindow; fillregion (minx,190,maxx,199,0);
  if configuration.soundeffects
    then displaystring ('Sound = On',(minx+maxx)div 2,192,1,0,center_)
    else displaystring ('Sound = Off',(minx+maxx)div 2,192,1,0,center_);
  setgraphwindow (x1,y1,x2,y2);
end;

procedure togglesound;
{ toggles the sound status (ON or OFF) and displays the status }
begin configuration.soundeffects := not (configuration.soundeffects); displaysoundstatus; end;

procedure setsound (freq : integer);
{ activates a sound frequency only if the sound is turned on }
begin if configuration.soundeffects then sound (freq) else nosound; end;

procedure music (f,d : integer);
{ eliminates the nuisance of using DELAY after SETSOUND all the time }
begin setsound (f); delay (d); end;

procedure wrapcoordinates (var x,y : integer);
{ wraps coordinates for x and y, respectively }
begin
  if x <= (-spritesizex) then x := x + spritesizex * (columns+1)
    else if x > ((maxx+1)-minx) then x := x - spritesizex * (columns+1);
  if y <= (-spritesizey) then y := y + spritesizey * (rows+1)
    else if y > ((maxy+1)-miny) then y := y - spritesizey * (rows+1);
end;

{ conversion of screen pixel coordinates to game board coordinates.  Returns -1 if this
  coordinate does not turn out to be an integer }

function bx (gx : integer) : integer;
var x : integer;
begin
  if (gx mod spritesizex) = 0 then x := gx div spritesizex + 1 else x := -1;
  if (x < 1) or (x > columns) then x := -1; bx := x;
end;

function by (gy : integer) : integer;
var y : integer;
begin
  if (gy mod spritesizey) = 0 then y := gy div spritesizey + 1 else y := -1;
  if (y < 1) or (y > rows) then y := -1; by := y;
end;

{ these functions convert board coordinates to graphics coordinates }
function gx (bx : integer) : integer; begin gx := (bx - 1) * spritesizex; end;
function gy (by : integer) : integer; begin gy := (by - 1) * spritesizey; end;

function between (d1,d2 : direction) : direction;
{ picks out a random direction between two directions (in scalar terms) }
begin between := direction (random (ord (d2) - ord (d1) + 1) + ord (d1)); end;

function tooclose (x1,y1,x2,y2 : integer) : boolean;
{ determines whether objects placed at given coordinates are "too close" together }
begin tooclose := (abs (x1-x2) <= spritesizex) and (abs (y1-y2) <= spritesizey); end;

function mouthopen : integer;
{ determines how wide player's mouth is open at given coordinates }
var open,dx,dy : integer;
begin
  dx := (spritesizex + spritex [player]) mod spritesizex;
  dy := (spritesizey + spritey [player]) mod spritesizey;
  if dx = 0 then open := dy div 2; if dy = 0 then open := dx div 2;
  if open > 2 then open := 4 - open; mouthopen := open;
end;

function cango (gx,gy : integer; dir : direction) : boolean;
{ determines whether anything placed at given coordinates can travel in a given direction }
var c,x,y,fx,fy : integer; d : direction; temp : boolean;
begin
  temp := true; x := bx (gx); y := by (gy);
  case incx [dir] of
    -1 : fx := px (x);
     0 : fx := x;
     1 : fx := nx (x);
  end;
  case incy [dir] of
    -1 : fy := py (y);
     0 : fy := y;
     1 : fy := ny (y);
  end;
  if (x <> -1) and (y <> -1) then if (currentboarddata [currentplayer,fx,fy] = __wall)
    then temp := false;
  if (x = -1) and (dir in [up,down]) then temp := false;
  if (y = -1) and (dir in [left,right]) then temp := false;
  cango := temp;
end;

procedure determine_can_and_cannot_go;
{ determines whether each ghost or bonus can or cannot travel in each direction }
var dir : direction; sprite : integer;
begin
  for sprite := -1 to numberofghosts [currentplayer] do for dir := still to down do
    go [sprite,dir] := cango (spritex [sprite],spritey [sprite],dir);
end;

{ procedures to increment x and y coordinates for each sprite by 1 }
procedure incrementx (sprite : integer);
begin futurex [sprite] := futurex [sprite] + incx [spritedir [sprite]]; end;
procedure incrementy (sprite : integer);
begin futurey [sprite] := futurey [sprite] + incy [spritedir [sprite]]; end;

procedure determinefuturecoordinates;
{ determines future X and Y coordinates for each sprite }
var sprite,c : integer;
begin
  for sprite := -1 to numberofghosts [currentplayer] do
    begin
      futurex [sprite] := spritex [sprite]; futurey [sprite] := spritey [sprite];
      incrementx (sprite); incrementy (sprite);
      for c := 2 to increment [sprite] do if bx (futurex [sprite])=-1 then incrementx (sprite);
      for c := 2 to increment [sprite] do if by (futurey [sprite])=-1 then incrementy (sprite);
      wrapcoordinates (futurex [sprite],futurey [sprite]);
    end;
{ determine if any ghosts are too close together }
  for sprite := 1 to numberofghosts [currentplayer] do
    if tooclose (spritex [player],spritey [player],spritex [sprite],spritey [sprite])
      then
        case ghoststatus [sprite] of
          _dangerous_ : fate [sprite] := _kill_;
             _edible_ : begin
                          futurex [sprite] := initspritex [currentplayer,sprite];
													futurey [sprite] := initspritey
													[currentplayer,sprite]; fate [sprite] := _eat_;
													ghoststatus [sprite] := _dangerous_; increment
													[sprite] := dangerousghostincr; end; end else fate
													[sprite] := _nothing_; end;

procedure closestonewaygates;
var sprite,closest : integer;
begin
	for sprite := 1 to numberofghosts [currentplayer] do
		begin



function chasedirection (ghost : integer) : direction;
{ This is the "intelligence" of this program.  This procedure gives the direction that any
  ghost will go to chase Mr. Muncher.  If you want to run away from Mr. Muncher, simply use
  this function as the index to the REVERSEDIR array. }
var
  best,second, { best and second best direction to go } temp,t : direction;
	x,y : integer;
begin
	if passedonewaygate
		then
			begin
				x := spritex [player];
				y := spritey [player];
			end
		else
			begin
				x := ghostgatex [ghost];
				y := ghostgatey [ghost];
			end;
  temp := still;
{ approach player horizontally or vertically }
	if x < spritex [ghost] then best := left else best := right;
	if y < spritey [ghost] then second := up else second := down;
{ cannot go in reverse; if dead end can stop then reverse }
  go [ghost,reversedir [spritedir [ghost]]] := false;
{ use either approach }
	if not (y = spritey [ghost]) then
		if (random (2) = 1) or (x = spritex [ghost]) then
      begin t := best; best := second; second := t; end;
{ determine direction ghost will go }
  if go [ghost,best] then temp := best
    else if go [ghost,second] then temp := second
    else if go [ghost,reversedir [second]] then temp := reversedir [second]
    else if go [ghost,reversedir [best]] then temp := reversedir [best]
    else temp := still;
  if (bx (spritex [ghost]) = -1) or (by (spritey [ghost]) = -1) then temp := spritedir [ghost];
  chasedirection := temp;
end;

procedure selectnumberofplayers;
{ inputs the # of players -- used by main procedure }
var key,maxch : char; buffer : array [1..73,1..80] of byte;
begin
  if configuration.scrollworks then seelines (0);
  clearscreen; displaystring ('SELECT NUMBER OF PLAYERS',160,64,1,0,center_);
  displaystring ('Press',160,84,3,0,center_);
  displaystring ('[1] for one player,',160,100,2,0,center_);
  displaystring ('[2] for two players,',160,112,2,0,center_);
  displaystring ('or [Esc] to return to main menu',160,128,2,0,center_);
  if configuration.scrollworks then slowdown;
  maxch := char (ord ('0') + maxplayers);
  repeat key := readkey; until key in ['1'..maxch,#27];
  if key in ['1'..maxch] then numberofplayers := ord (key) - ord ('0');
  if key = #27 then numberofplayers := 0;
  turnclearscreen (40,64,279,135,0,buffer);
end;

procedure loadboard;
{ loads up the data for a game board from the disk }
var datafile : file; x : integer; st : string [3];
begin
  x := 0;
  repeat
    assign (datafile,boardfile (currentround [currentplayer]));
    reset (datafile,sizeof (boardtype)); exiting := not (ioresult = 0);
    if (not exiting) then blockread (datafile,currentboarddata [currentplayer],1);
    close (datafile); x := x + 1;
  until (not exiting) or (x = 2);
  if exiting then
    begin
      screengraphwindow; clearscreen; x := 160;
      displaystring ('The data file for',x,20,3,0,center_);
      str (currentround [currentplayer],st);
      displaystring ('board number '+st,x,32,1,0,center_);
      displaystring ('does not exist on disk.',x,44,3,0,center_);
      displaystring ('Please use the board',x,60,3,0,center_);
      displaystring ('editor to create a new',x,70,3,0,center_);
      displaystring ('game board.',x,80,3,0,center_);
      displaystring ('Press any key to continue...',x,190,2,0,center_);
      pressanykey; exit;
    end;
end;

procedure displayboardpart (x,y : integer);
{ displays one part of the board on the board editor screen }
var l,r,u,d : boolean;
begin
  l := (currentboarddata [currentplayer,px(x),y] = __wall);
  r := (currentboarddata [currentplayer,nx(x),y] = __wall);
  u := (currentboarddata [currentplayer,x,py(y)] = __wall);
  d := (currentboarddata [currentplayer,x,ny(y)] = __wall);
  with icons do
    begin
      case currentboarddata [currentplayer,x,y] of
        __enemy,__player,
        __eraser : fillregion (gx(x),gy(y),gx(x)+7,gy(y)+7,0);
           __dot : put (_dot,gx(x),gy(y));
        __energy : put (_energizer,gx(x),gy(y));
          __wall : put (_wall [l,r,u,d],gx(x),gy(y));
      end;
    end;
end;

procedure displayboard;
{ displays the current board on board editor screen }
var x,y : integer;
begin for x := 1 to columns do for y := 1 to rows do displayboardpart (x,y); end;

procedure sizeget (var buffer; x,y,xsize,ysize : integer);
{ gets an image from the screen using it's size in pixels }
begin get (buffer,x,y,x+xsize-1,y+ysize-1); end;

procedure getwhatwasthereforsprite (sprite : integer);
{ gets "what was there" before a sprite writes over it }
var i : integer;
begin
  if (sprite = bonus) and (not bonuspresent) then exit;
  if (sprite = bonus) and (currentbonustype in [_strawberry_,_banana_])
    then i := spritesizeydif else i := 0;
  screengraphwindow;
  sizeget (whatwasthere [sprite],minx+spritex [sprite],miny+spritey [sprite]-i,
           spritesizex,spritesizey+i*2);
  gamegraphwindow;
end;

procedure erasesprite (sprite : integer);
{ erases the animated sprite with what it overwrote }
var i,x,y : integer;
begin
  if (sprite = bonus) and (not bonuspresent) then exit;
  if (sprite = bonus) and (currentbonustype in [_strawberry_,_banana_])
    then i := spritesizeydif else i := 0;
  put (whatwasthere [sprite],spritex [sprite],spritey [sprite]-i);
end;

procedure displaysprite (sprite : integer);
{ displays an animated sprite }
var x,y : integer;
begin
  x := spritex [sprite]; y := spritey [sprite]; getwhatwasthereforsprite (sprite);
  if (sprite = bonus) and (not bonuspresent) then exit;
  case sprite of
     bonus : if bonuspresent then with icons do
               case currentbonustype of
                     _cherry_ : put (_cherry,x,y);
                 _strawberry_ : put (_strawberry,x,y-spritesizeydif);
                     _banana_ : put (_banana,x,y-spritesizeydif);
                   _extraman_ : put (_extraman,x,y);
             end;
    player : with icons do
               if spritedir [sprite] = still then put (_creature [left,0],x,y)
                 else put (_creature [spritedir [sprite],mouthopen],x,y);
      else   with icons do
               case ghoststatus [sprite] of
                 _dangerous_ : put (_ghost [dangerous],x,y);
                    _edible_ : begin
                                 if timelefttoeat > warningtime then put (_ghost [edible],x,y)
                                   else
                                     begin
                                       if (timelefttoeat and 2) = 2
                                         then put (_ghost [flash1],x,y)
                                         else put (_ghost [flash2],x,y);
                                     end;
                               end;
               end;
  end;
end;

procedure displaysprites;
{ initially puts the sprites on the game board }
var sprite : integer;
begin for sprite := -1 to numberofghosts [currentplayer] do displaysprite (sprite); end;

procedure gameovermessage;
{ "Game Over" graphics }
var st : string [1]; count : integer;
begin
  screengraphwindow;
  str (currentplayer,st); displaystring ('PLAYER #'+st,messagex,90,1,2,center_);
  displaystring ('GAME OVER!',messagex,102,0,2,center_);
  setgraphwindow (messagex-44,90,messagex+44,113); colortable (1,0,2,3);
  for count := 1 to 12 do begin fillscreen (-1); delay (150); end;
  setgraphwindow (messagex-44,90,messagex+44,113);
  colortable (0,1,2,3); fillscreen (2); gamegraphwindow;
end;

function pixelmemory (x,y : integer) : word;
{ returns the offset address (segment = $B800) of a pixel on the screen }
begin pixelmemory := ((y and 1) shl 13) + (y shr 1) * 80 + (x shr 2); end;

const
  bitdata : array [0..9,0..7] of byte =
    (($7C,$82,$82,$82,$82,$82,$82,$7C),($08,$18,$28,$08,$08,$08,$08,$08),
     ($7C,$82,$02,$02,$1C,$60,$80,$FE),($7C,$82,$02,$3C,$02,$02,$82,$7C),
     ($04,$0C,$14,$24,$44,$FE,$04,$04),($FE,$80,$FC,$02,$02,$02,$82,$7C),
     ($7C,$82,$80,$FC,$82,$82,$82,$7C),($FE,$02,$04,$08,$10,$20,$40,$80),
     ($7C,$82,$82,$7C,$82,$82,$82,$7C),($7C,$82,$82,$82,$7E,$02,$82,$7C));
  int = $1F;
var
  oldint : array [0..1] of integer;

procedure usenewfont;
begin
  move (memw [0:int*4],oldint,4);
  memw [0:int*4] := ofs (bitdata);
  memw [0:int*4+2] := seg (bitdata);
end;

procedure restorefont;
begin
  move (oldint,memw [0:int*4],4);
end;

{ --- below are three procedures for displaying each player's score, current round, and men
      left, respectively --- }

procedure displayscore (color : integer);
var st : string [10]; p : integer;
begin
  str (currentscore [currentplayer]:0:0,st);
  for p := 1 to length (st) do
    if st [p] in ['0'..'9'] then st [p] := chr (ord (st [p]) + 80);
  gotoxy (scorex [currentplayer],scorey [currentplayer]);
  textcolor (color); write (st:9);
end;

procedure displayround (color : integer);
var st : string [3];
begin
  str (currentround [currentplayer],st); while length (st) < 3 do st := '0' + st;
  screengraphwindow;
  if not (menleft [currentplayer] = gameover)
    then displaystring (st,roundx[currentplayer],roundy[currentplayer],color,2,center_);
  gamegraphwindow;
end;

procedure displaymen (color : integer);
var st : string [3];
begin
  if menleft [currentplayer] < 0 then st := '---' else str (menleft [currentplayer],st);
  while length (st) < 3 do st := '0' + st;
  screengraphwindow;
  if menleft [currentplayer] = gameover
    then displaystring ('Game Over',messagex,meny [currentplayer],1,2,center_)
    else displaystring (st,menx[currentplayer],meny[currentplayer],color,2,center_);
  gamegraphwindow;
end;

procedure addscore (add : integer);
{ simply adds a value to the player's score and determines if gets extra man }
begin
  currentscore [currentplayer] := currentscore [currentplayer] + add;
  extramancountdown [currentplayer] := extramancountdown [currentplayer] - add;
  if extramancountdown [currentplayer] < 0 then
    begin
      menleft [currentplayer] := menleft [currentplayer] + 1; displaymen (3);
      extramancountdown [currentplayer] := extramancountdown [currentplayer] + eachbonusman;
    end;
  displayscore (1);
end;

procedure siren (freq,mult : real); { sound effect } var f : real;
begin f := freq; repeat music (round (f),3); f := f * mult; until (f) > (freq * 2); end;

procedure addscoreforeating (addend : integer);
{ places an image where player is informing him that he got a certain score, for ghost/bonus }
var savedarea,image : iconscore; sizex,sizey,x,y,s,add,f : integer;

begin
  add := addend;
  for s := 1 to 4 do if ghostscore [s] = add then add := s;
  case add of
    1 : move (icons._200,image,sizeof(image));
    2 : move (icons._400,image,sizeof(image));
    3 : move (icons._800,image,sizeof(image));
    4 : move (icons._1600,image,sizeof(image));
        cherryscore : move (icons._100,image,sizeof(image));
    strawberryscore : move (icons._500,image,sizeof(image));
        bananascore : move (icons._1000,image,sizeof(image));
  end;
  sizex := memw [seg(image) : ofs(image)+2]; sizey := memw [seg(image) : ofs(image)+4];
  x := spritex [player] + (spritesizex-sizex) div 2;
  y := spritey [player] + (spritesizey-sizey) div 2;
  if x < 0 then x := 0; if y < 0 then y := 0;
  if x > (maxx-sizex+1) then x := maxx-sizex+1;
  if y > (maxy-sizey+1) then y := maxy-sizey+1;
  sizeget (savedarea,x,y,sizex,sizey); addscore (addend);
  put (image,x,y); siren (440.0,1.004); nosound; put (savedarea,x,y);
end;

procedure scrolldown (x1,y1,x2,y2,lines,color : integer);
{ scrols down a portion of the screen window.  Note that the
  the right two bits of the X1,X2 coordinates will be zeroed. }
var y,s : integer; screen : array [0..16383] of byte absolute $B800:0;
begin
  order (x1,x2); order (y1,y2); s := (x2 div 4) - (x1 div 4) + 1;
  for y := y2-lines downto y1 do
    move (screen [pixelmemory (x1,y)],screen [pixelmemory (x1,y+lines)],s);
  for y := y1 to y1+lines-1 do fillchar (screen [pixelmemory (x1,y)],s,$55*(color and 3));
end;

procedure ifhighscorethenenter;
{ if current player's high score is in top ten, then enters his/her name }
var l,r,rank,p : integer; st : string [64]; x1,y1,x2,y2 : integer;
begin
  screengraphwindow;
  str (currentplayer,st); st := 'PLAYER #'+st;
{ determine rank of player }
  rank := -1;
  for r := 10 downto 1 do if currentscore [currentplayer] > topten [r].score then rank := r;
  if rank = -1 then { not ranked in top ten }
    begin
      fadescreen (0);
      displaystring ('Sorry,',160,70,2,0,center_);
      displaystring (st,160,90,1,0,center_);
      displaystring ('Your score does not rank',160,110,2,0,center_);
      displaystring ('in the top ten.',160,120,2,0,center_);
      displaystring ('Press any key to continue...',160,190,3,0,center_);
      pressanykey; fillregion (0,190,319,199,0);
    end
  else { ranked in top ten }
    begin
    { move low scores out of the way }
      move (topten [rank],topten [rank+1],(10-rank)*sizeof(topten [1]));
    { display message }
      fadescreen (0);
      displaystring ('Congratulations,',160,40,2,0,center_);
      displaystring (st,160,60,1,0,center_);
      displaystring ('You have the',160,80,2,0,center_);
      str (rank,st); displaystring ('NUMBER '+st,160,90,3,0,center_);
      displaystring ('score in the top ten.',160,100,2,0,center_);
      displaystring ('Type in your name and press <Enter>:',160,120,1,0,center_);
      with topten [rank] do
        begin
        { input name, and set new top ten scores data }
          score := currentscore [currentplayer]; round := currentround [currentplayer];
          str (score:0:0,st); l := 229 - fromside * 2 - sizestr (st);
          box3d (155 - l div 2,136,164 + l div 2,153,1,2,2,2);
          inputstring (name,160 - l div 2,140,l,30,1,0);
        { load high score screen }
          if configuration.scrollworks
            then begin jerkup; savehighscores; loadscreen (HighScoresScreenFile); slowdown; end
            else
              begin
                fadescreen (0); savehighscores;
                loadscreenwithfade (HighScoresScreenFile);
              end;
        { scroll down what's below where new score is placed }
          x1 := fromside+25; x2 := 319 - fromside; y1 := 54 + rank * 11; y2 := 64 + 10 * 11;
          scrolldown (x1,y1,x2,y2,11,2);
        { display new information on screen }
          str (rank:0,st); st := st + '.';
          displaystring (st,fromside+15,54+rank*11,0,2,right_);
          displaystring (name,fromside+25,54+rank*11,1,2,left_);
          str (score:0:0,st); displaystring (st,274-fromside,54+rank*11,3,2,right_);
          str (round:0,st); displaystring (st,319-fromside,54+rank*11,3,2,right_);
        { save new high score screen and press any key }
          savescreen (HighScoresScreenFile);
          displaystring ('Press any key to continue...',160,190,1,0,center_);
          pressanykey;
        end;
    end;
  if not (playersleft = 0)
    then
      begin
        loadscreenwithfade (GameScreenFile); displaysoundstatus;
        l := currentplayer;
        for p := 1 to numberofplayers do
          begin
            currentplayer := p;
            displayscore (2); displayround (0); displaymen (0);
          end;
        currentplayer := l;
      end
    else if configuration.scrollworks then jerkup else fadescreen (0);
  gamegraphwindow;
end;

procedure lowermatch (var a,b : integer);
{ sets two variables equal to value of lower variable }
begin if a < b then b := a else a := b; end;

var spritegroup : array [-1..maxghosts] of integer; { used in sprite groups }

procedure determinespritegroups;
{ determines grouping arrangement of animated sprites }
var s1,s2 : integer;
begin
  for s1 := -1 to numberofghosts [currentplayer] do spritegroup [s1] := s1;
  for s1 := -1 to numberofghosts [currentplayer] - 1 do
    for s2 := s1+1 to numberofghosts [currentplayer] do
      if tooclose (spritex [s1],spritey [s1],spritex [s2],spritey [s2])
      or tooclose (spritex [s1],spritey [s1],futurex [s2],futurey [s2])
      or tooclose (futurex [s1],futurey [s1],spritex [s2],spritey [s2])
      or tooclose (futurex [s1],futurey [s1],futurex [s2],futurey [s2])
        then lowermatch (spritegroup [s1],spritegroup [s2]);
end;

procedure movespritesaccordingtogroups;
{ moves each sprite according to the "sprite groups" }
var group,sprite,x,y,f : integer;
begin
  killed := false; gamegraphwindow;
  for group := -1 to numberofghosts [currentplayer] do
    begin
    { erase each animated sprite in this group }
      for sprite := numberofghosts [currentplayer] downto -1 do
        if spritegroup [sprite] = group then erasesprite (sprite);
    { if player is in this group and ate a dot or energy pellet then do appropriate action }
      if (spritegroup [player] = group) and atesomething then
        begin
          x := bx (futurex [player]); y := by (futurey [player]);
          currentboarddata [currentplayer,x,y] := __eraser; displayboardpart (x,y);
        end;
    { if there is a ghost in this group then do appropriate actions }
      for sprite := 1 to numberofghosts [currentplayer] do
        if spritegroup [sprite] = group then
          case fate [sprite] of
            _kill_ : killed := true;
             _eat_ : begin
                       addscoreforeating (ghostscore [scorelevel]);
                       if scorelevel < ghostscores then scorelevel := scorelevel + 1;
                     end;
          end;
    { if bonus is in this group then do appropriate actions }
      if (spritegroup [bonus] = group) then
        begin { bonus is in this group, so... }
        { decrement countdown until at -1 }
          if bonuscountdown > -1 then bonuscountdown := bonuscountdown - 1;
        { if countdown passes 0 initialize bonus }
          if bonuscountdown = 0 then
            begin
              bonuspresent := true;
              repeat spritedir [bonus] := between (left,down);
                until cango (spritex [bonus],spritey [bonus],spritedir [bonus]);
            { point value gets higher in each round }
              case currentround [currentplayer] of
                1 : currentbonustype := _cherry_;
                2 : currentbonustype := _strawberry_;
                3 : currentbonustype := _banana_;
                else currentbonustype := _extraman_;
              end;
            end;
          if tooclose (spritex [bonus],spritey [bonus],spritex [player],spritey [player]) then
            if bonuspresent then
              begin { ate a bonus }
                bonuscountdown := -2; bonuspresent := false;
                case currentbonustype of
                      _cherry_ : addscoreforeating (cherryscore);
                  _strawberry_ : addscoreforeating (strawberryscore);
                      _banana_ : addscoreforeating (bananascore);
                    _extraman_ : begin
                                   menleft [currentplayer] := menleft [currentplayer] + 1;
                                   displaymen (3);
                                 end;
                end;
            end;
        end;
    { display animated sprites in this group at their new location, if player not killed }
      if not killed then
        for sprite := -1 to numberofghosts [currentplayer] do
          if spritegroup [sprite] = group then
            begin
              x := futurex [sprite]; y := futurey [sprite]; wrapcoordinates (x,y);
              spritex [sprite] := x; spritey [sprite] := y; displaysprite (sprite);
            end;
    { make sound effect if player has eaten something }
      if (spritegroup [player] = group) and atesomething then
        begin
          if ateenergy
            then
              begin
                music ( 988,15); music (784,15); music (698,15); music (784,15);
                music ( 988,15); music (784,15); music (698,15); music (784,15);
                music (1047,15); music (784,15); music (698,15); music (784,15);
                music (1047,15); music (784,15); music (698,15); music (784,15);
              end
            else
              begin
                music (110,5); music (123,5); music (139,5); music (156,5);
                music (175,5); music (196,5); music (220,5);
              end;
          nosound;
        end;
    end;
  if killed then
    begin { player gets killed }
    { rotate player's image until face up }
      for sprite := 0 to 16 do
        begin
          put (icons._deadcreature [sprite mod 8],spritex [player],spritey [player]);
          for f := 88 downto 44 do music (f*10 - 27*sprite,2);
        end;
      nosound;
      colortable (0,3,0,2);
      for f := 1 to 3 do
        begin
          fillregion (spritex [player],spritey [player],
                      spritex [player] + spritesizex,spritey [player] + spritesizey,-1);
          delay (250);
        end;
      colortable (0,1,2,3);
      menleft [currentplayer] := menleft [currentplayer] - 1;
      if menleft [currentplayer] < 0 then
        begin { game over }
          menleft [currentplayer] := gameover; playersleft := playersleft - 1;
          gameovermessage; ifhighscorethenenter;
        end;
      exit;
    end;
end;

procedure initializecurrentround;
{ initialize the data for a new board for a given player }
var row,col,ghostcount,playercount,dotcount : integer; st : string [3];

    procedure errormessage;
    begin
      screengraphwindow; seelines (100); clrscr;
      str (currentround [currentplayer],st);
      displaystring ('There is an error in board '+st+'.',160,80,3,0,center_);
      displaystring ('Please use the board editor',160,100,3,0,center_);
      displaystring ('to make corrections.',160,110,3,0,center_);
      displaystring ('Press any key to continue...',160,190,1,0,center_);
      pressanykey; exiting := true;
      if configuration.scrollworks then jerkup else fadescreen (0);
    end;

begin
  loadboard; if exiting then exit;
  ghostcount := 0; dotcount := 0; playercount := 0;
  for row := 1 to rows do
    for col := 1 to columns do
      begin
        case currentboarddata [currentplayer,col,row] of
          __player : begin
                       playercount := playercount + 1;
                       if playercount = 2 then begin errormessage; exit; end;
                       initspritex [currentplayer,player] := gx (col);
                       initspritey [currentplayer,player] := gy (row);
                       spritex [player] := gx (col); spritey [player] := gy (row);
                       spritedir [player] := still; spritedir [bonus] := still;
                       initspritex [currentplayer,bonus] := gx (col);
                       initspritey [currentplayer,bonus] := gy (row);
                       spritex [bonus] := gx (col); spritey [bonus] := gy (row);
                     end;
           __enemy : begin
                       ghostcount := ghostcount + 1;
                       if ghostcount > maxghosts then begin errormessage; exit; end;
                       initspritex [currentplayer,ghostcount] := gx (col);
                       initspritey [currentplayer,ghostcount] := gy (row);
                       spritex [ghostcount] := gx (col); spritey [ghostcount] := gy (row);
                      spritedir [ghostcount] := still; ghoststatus [ghostcount] := _dangerous_;
                     end;
             __dot : dotcount := dotcount + 1;
						__gate : begin
											 onewaygates [currentplayer] :=
												 onewaygates [currentplayer] + 1;
											 onewaygatex [onewaygates [currentplayer]] := gx (col);
											 onewaygatey [onewaygates [currentplayer]] := gy (col);
										 end;
        end;
      end;
  bonuspresent := false; bonuscountdown := bonusappeartime;
  dotsleft [currentplayer] := dotcount; numberofghosts [currentplayer] := ghostcount;
  displayscore (1); displayround (3); displaymen (3); displayboard; displaysprites;
end;

procedure playerreadygraphics;
{ "Player Ready" graphics }
const freq : array [1..15] of integer =
  (1047,784,659,659,880,698,523,523,784,659,523,523,587,494,523);
var st : string [1]; count : integer;
begin
  screengraphwindow; str (currentplayer,st);
  displaystring ('PLAYER #'+st,messagex,90,1,2,center_);
  displaystring ('READY!',messagex,102,0,2,center_);
  setgraphwindow (messagex-44,90,messagex+44,113);
  colortable (1,0,2,3);
  for count := 1 to 15 do begin fillscreen (-1); music (freq [count],120); end; nosound;
  setgraphwindow (messagex-44,90,messagex+44,113);
  colortable (0,1,2,3); fillscreen (2); gamegraphwindow;
end;

procedure changebonusdirection;
{ changes direction of bonus sprite }
var lt,rt : direction;
begin
{ if bonus direction is still, then choose random one }
  if spritedir [bonus] = still then
    repeat spritedir [bonus] := between (left,down);
      until go [bonus,spritedir [bonus]];
{ if can go in current direction, then exit }
  if (go [bonus,spritedir [bonus]]) then exit;
{ determine direction after turning left or right }
  rt := turnright [spritedir [bonus]]; lt := reversedir [rt];
{ if cannot turn right or left, go in reverse.  Otherwise, turn either way }
  case go [bonus,lt] of
    false : if go [bonus,rt]
              then spritedir [bonus] := rt
              else { if cannot turn left or right, go in reverse }
                spritedir [bonus] := reversedir [spritedir [bonus]];
     true : if go [bonus,rt]
              then { if can turn either way, randomly select it }
                begin
                  if random (2) = 0 then spritedir [bonus] := lt
                    else spritedir [bonus] := rt;
                end
              else spritedir [bonus] := lt;
  end;
end;

procedure setincrements;
begin
  with configuration do
    begin
      playerincr := smoothness * playerspeed_constant;
      dangerousghostincr := smoothness * dangerousghostspeed_constant;
      edibleghostincr := smoothness * edibleghostspeed_constant;
      bonusincr := smoothness * bonusspeed_constant;
      bonusappeartime := bonusappeartime_constant div smoothness;
      timeyouhavetoeat := timeyouhavetoeat_constant div smoothness;
      warningtime := warningtime_constant div smoothness;
    end;
  if playerincr = 6 then playerincr := 4;
  if dangerousghostincr = 6 then dangerousghostincr := 4;
  increment [bonus] := bonusincr; increment [player] := playerincr;
end;

procedure optionsmenu;
{ options menu called from game play, used to set game speed, other factors }
const fromside = 8;
var x,x2 : integer; ch : char;

  { the next 3 procedures display each game status }

  procedure soundstatus; var st : string [3];
  begin
    fillregion (x2-24,72,x2,83,0);
    if configuration.soundeffects then st := 'On' else st := 'Off';
    displaystring (st,x2,72,1,0,right_);
  end;

  procedure speed; var st : string [5];
  begin
    fillregion (x2-40,84,x2,95,0); str (configuration.animationspeed,st);
    displaystring (st,x2,84,1,0,right_);
  end;

  procedure smoothness; var st : string [1];
  begin
    fillregion (x2-40,96,x2,107,0); str (configuration.smoothness,st);
    displaystring (st,x2,96,1,0,right_);
  end;

  procedure input (st : string255; x,y,fg1 : integer; var n : integer;
                   min,max,fg,bg,fg2 : integer);
  { input number with prompt }
  var s : integer;
  begin
    displaystring (st,x,y,fg1,bg,left_); x := x + sizestr (st); s := n;
    inputnumber (s,min,max,x,y,x+40,y+9,fg,bg,fg2); if not (s = -1) then n := s;
    fillregion (x-sizestr (st),y,x+40,y+9,0);
  end;

begin { procedure optionsmenu }
  screengraphwindow; fillregion (minx,190,maxx,199,0);
  x := (maxx - minx) div 2; x2 := maxx - minx + 1 - fromside;
  gamegraphwindow; fillscreen (0);
  displaystring ('KEYS TO PLAY',x,4,1,0,center_); draw (x-40,13,x+40,13,1);
  displaystring ('Movement -- arrow keys',x,16,3,0,center_);
  displaystring ('Pause -- P',x,27,3,0,center_);
  displaystring ('Quit game -- Esc',x,38,3,0,center_);
  rectangle (x-60,52,x+60,56,2); rectangle (x-59,53,x+59,55,3); draw (x-58,54,x+58,54,1);
  displaystring ('OPTIONS',x,60,1,0,center_); draw (x-40,69,x+40,69,1);
  displaystring ('S',fromside+16,72,1,0,right_);
  displaystring ('Toggle sound:',fromside+28,72,3,0,left_);

  displaystring ('G',fromside+16,84,1,0,right_);
  displaystring ('Set game speed:',fromside+28,84,3,0,left_);

  displaystring ('M',fromside+16,96,1,0,right_);
  displaystring ('Set smoothness:',fromside+28,96,3,0,left_);

  displaystring ('Esc',fromside+16,108,1,0,right_);
  displaystring ('Return to game',fromside+28,108,3,0,left_);

  soundstatus; speed; smoothness;
  repeat
    ch := readkey; if ch = #0 then begin ch := readkey; ch := #0; end;
    case upcase (ch) of
      'S' : begin configuration.soundeffects := not configuration.soundeffects; soundstatus; end;
      'G' : begin
              input ('Enter game speed:  ',fromside,maxy-miny-12,3,
                configuration.animationspeed,0,32767,1,0,2);
              speed;
            end;
      'M' : begin
              input ('Enter smoothness:  ',fromside,maxy-miny-12,3,
                configuration.smoothness,1,4,1,0,2);
              smoothness;
            end;
    end;
  until ch = #27;
  gamegraphwindow; displayboard; displaysoundstatus; displaysprites; setincrements;
end;

procedure gameplay;
var
  x,y,f,
{ counter for sprite loops in this procedure } sprite : integer;
{ direction Mr. Muncher will go when blocked by wall, used for "typeahead" feature }
  waiting : direction;
begin
{ initialization procedure }
  displayscore (1); displayround (3); displaymen (3); gamegraphwindow;
  timelefttoeat := 0;
  if not (dotsleft [currentplayer] = 0) then
    begin
      for sprite := -1 to numberofghosts [currentplayer] do
        begin
          spritex [sprite] := initspritex [currentplayer,sprite];
          spritey [sprite] := initspritey [currentplayer,sprite];
          spritedir [sprite] := still;
        end;
      for sprite := 1 to numberofghosts [currentplayer] do
        ghoststatus [sprite] := _dangerous_;
      bonuspresent := false; bonuscountdown := bonusappeartime;
      waiting := still; gamegraphwindow;
      if not (previousplayer = currentplayer) then displayboard;
      displaysprites; playerreadygraphics;
    end;
  repeat
    if dotsleft [currentplayer] = 0 then { next round }
      begin
        currentround [currentplayer] := currentround [currentplayer] + 1;
        initializecurrentround; if exiting then exit;
        waiting := still; playerreadygraphics;
      end;
  { determine increment value for each ghost's sprite }
    for sprite := 1 to numberofghosts [currentplayer] do
      if ghoststatus [sprite] = _dangerous_ then increment [sprite] := dangerousghostincr
        else increment [sprite] := edibleghostincr;
  { determine whether each sprite can travel in each direction }
    determine_can_and_cannot_go;
  { change ghosts' and bonus's directions }
    for sprite := 1 to numberofghosts [currentplayer] do
      spritedir [sprite] := chasedirection (sprite);
    if bonuspresent then changebonusdirection;
  { change player's direction using input from keyboard }
    if keypressed then
      begin
        ch := upcase (readkey);
        case ch of
          #27 : begin exiting := true; exit; end;
           #0 : begin
                  ch := readkey;
                  case ch of
                    'H' : waiting := up;
                    'K' : waiting := left;
                    'M' : waiting := right;
                    'P' : waiting := down;
               {F1} ';' : optionsmenu;
                  end;
                end;
          'S' : togglesound;
          'P' : begin pause (minx,miny,maxx,maxy); displaysoundstatus; end;
        end;
      end;
  { determine player's direction by using key }
    if not (cango (spritex [player],spritey [player],spritedir [player]))
      then spritedir [player] := still;
    if (cango (spritex [player],spritey [player],waiting)) and (waiting in [left..down])
      then begin spritedir [player] := waiting; waiting := still; end;
  { determine future coordinates of each sprite }
    determinefuturecoordinates;
  { determine whether creature ate food or energy pellet }
    x := bx (futurex [player]); y := by (futurey [player]);
    atesomething := false;
    if not ((x = -1) or (y = -1)) then
      case currentboarddata [currentplayer,x,y] of
           __dot : begin
                     addscore (dotscore); atesomething := true; ateenergy := false;
                     dotsleft [currentplayer] := dotsleft [currentplayer] - 1;
                   end;
        __energy : begin
                     addscore (energyscore); atesomething := true; ateenergy := true;
                     scorelevel := 1; timelefttoeat := timeyouhavetoeat;
                     for sprite := 1 to numberofghosts [currentplayer] do
                       begin
                         ghoststatus [sprite] := _edible_;
                         increment [sprite] := edibleghostincr;
                       end;
                   end;
      end;
    if timelefttoeat > 0
      then
        begin
          timelefttoeat := timelefttoeat - 1;
          if timelefttoeat = 0 then
            for sprite := 1 to numberofghosts [currentplayer] do
              begin
                ghoststatus [sprite] := _dangerous_;
                increment [sprite] := dangerousghostincr;
              end;
        end;
  { move each sprite }
    for f := 1 to configuration.animationspeed do;
    determinespritegroups; movespritesaccordingtogroups;
  until killed;
  if not (menleft [currentplayer] = gameover) then
    begin displayscore (2); displayround (0); displaymen (0); end;
  exiting := false; screengraphwindow;
end;

begin { procedure playthegame }
  selectnumberofplayers; if numberofplayers = 0 then exit;
  loadscreenwithfade (gamescreenfile);
  maxx := minx + spritesizex * columns - 1; maxy := miny + spritesizey * rows - 1;
  displaysoundstatus;
  setincrements; usenewfont;
  for currentplayer := 1 to numberofplayers do
    begin
      currentround [currentplayer] := 1; currentscore [currentplayer] := 0.0;
      extramancountdown [currentplayer] := firstbonusman;
      menleft [currentplayer] := startingmenleft;
      dotsleft [currentplayer] := 0; currentround [currentplayer] := 0;
      displayscore (2); displayround (0); displaymen (0);
     end;
  playersleft := numberofplayers; currentplayer := 1; previousplayer := 0;
  repeat
    exiting := false;
    if not (menleft [currentplayer] = gameover) then gameplay;
    if exiting then begin screengraphwindow; fadescreen (0); restorefont; exit; end;
    previousplayer := currentplayer;
    currentplayer := (currentplayer mod numberofplayers) + 1;
  until playersleft = 0;
  screengraphwindow; fadescreen (0); restorefont;
end;

